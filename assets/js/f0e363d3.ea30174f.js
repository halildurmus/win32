"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["8464"],{9255(e,n,i){i.r(n),i.d(n,{metadata:()=>t,default:()=>h,frontMatter:()=>l,contentTitle:()=>s,toc:()=>c,assets:()=>o});var t=JSON.parse('{"id":"core/memory-management-patterns","title":"Memory Management Patterns","description":"Allocating native memory is straightforward. Managing its lifetime correctly","source":"@site/docs/core/memory-management-patterns.md","sourceDirName":"core","slug":"/core/memory-management-patterns","permalink":"/docs/core/memory-management-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/halildurmus/win32/tree/main/website/docs/core/memory-management-patterns.md","tags":[],"version":"current","lastUpdatedBy":"Halil Durmus","lastUpdatedAt":1772220481000,"frontMatter":{"title":"Memory Management Patterns"},"sidebar":"mainSidebar","previous":{"title":"Memory Allocation","permalink":"/docs/core/memory-allocation"},"next":{"title":"Integer Types","permalink":"/docs/core/integer-types"}}'),r=i(74848),a=i(28453);let l={title:"Memory Management Patterns"},s,o={},c=[{value:"Manual Lifetime Management with <code>try</code> / <code>finally</code> Blocks",id:"manual-lifetime-management-with-try--finally-blocks",level:2},{value:"Scope-based Lifetime Management with <code>Arena</code> (Recommended)",id:"scope-based-lifetime-management-with-arena-recommended",level:2},{value:"Modeling Multiple Lifetimes with Nested <code>Arena</code>s",id:"modeling-multiple-lifetimes-with-nested-arenas",level:2},{value:"Selecting an Allocation Strategy",id:"selecting-an-allocation-strategy",level:2}];function d(e){let n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{CommonViewSourceCode:i}=n;return i||function(e,n){throw Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CommonViewSourceCode",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Allocating native memory is straightforward. ",(0,r.jsx)(n.strong,{children:"Managing its lifetime correctly"}),"\nis not."]}),"\n",(0,r.jsxs)(n.p,{children:["For most Win32 interop code,\n",(0,r.jsxs)(n.strong,{children:["scope-based lifetime management with ",(0,r.jsx)(n.code,{children:"Arena"})," should be the default"]}),".\nManual calls to ",(0,r.jsx)(n.a,{href:"https://pub.dev/documentation/win32/latest/win32/free.html",children:(0,r.jsx)(n.code,{children:"free()"})})," are a lower-level escape hatch for cases where\nmemory must outlive a lexical scope."]}),"\n",(0,r.jsxs)(n.h2,{id:"manual-lifetime-management-with-try--finally-blocks",children:["Manual Lifetime Management with ",(0,r.jsx)(n.code,{children:"try"})," / ",(0,r.jsx)(n.code,{children:"finally"})," Blocks"]}),"\n",(0,r.jsx)(n.p,{children:"At the lowest level, native memory must be freed explicitly."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["This pattern is ",(0,r.jsx)(n.strong,{children:"correct but low-level"}),", and should be reserved for cases\nwhere scope-based lifetime management is not viable."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The most basic safe pattern uses ",(0,r.jsx)(n.code,{children:"try"})," / ",(0,r.jsx)(n.code,{children:"finally"})," blocks, ensuring cleanup\nhappens regardless of success or failure:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",metastring:'title="customtitlebar.dart"',children:"bool isWindowMaximized(HWND hWnd) {\n  final windowPlacement = adaptiveCalloc<WINDOWPLACEMENT>()\n    ..ref.length = sizeOf<WINDOWPLACEMENT>();\n  // highlight-next-line\n  try {\n    final Win32Result(:value, :error) = GetWindowPlacement(\n      hWnd,\n      windowPlacement,\n    );\n    if (!value) throw WindowsException(error.toHRESULT());\n    return windowPlacement.ref.showCmd == SW_SHOWMAXIMIZED;\n  // highlight-next-line\n  } finally {\n    free(windowPlacement);\n  }\n}\n"})}),"\n",(0,r.jsx)(i,{href:"https://github.com/halildurmus/win32/blob/main/examples/customtitlebar.dart"}),"\n",(0,r.jsxs)(n.p,{children:["This approach is ",(0,r.jsx)(n.strong,{children:"correct"})," and ",(0,r.jsx)(n.strong,{children:"exception-safe"}),". However, it does not scale\nwell."]}),"\n",(0,r.jsx)(n.p,{children:"As the number of allocations grows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cleanup code becomes verbose"}),"\n",(0,r.jsx)(n.li,{children:"Control flow becomes harder to reason about"}),"\n",(0,r.jsxs)(n.li,{children:["Missing a single ",(0,r.jsx)(n.code,{children:"free()"})," introduces a leak"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For anything beyond trivial cases, a higher-level pattern is strongly preferred."}),"\n",(0,r.jsxs)(n.h2,{id:"scope-based-lifetime-management-with-arena-recommended",children:["Scope-based Lifetime Management with ",(0,r.jsx)(n.code,{children:"Arena"})," (Recommended)"]}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.a,{href:"https://pub.dev/documentation/ffi/latest/ffi/Arena-class.html",children:(0,r.jsx)(n.code,{children:"Arena"})})," tracks all allocations made through it and releases them\nautomatically when the scope exits:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cleanup is automatic and exception-safe"}),"\n",(0,r.jsx)(n.li,{children:"Error paths require no special handling"}),"\n",(0,r.jsx)(n.li,{children:"Ownership and lifetimes are explicit in the code structure"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",metastring:'title="process.dart"',children:"DateTime processCreationTime() {\n  // highlight-next-line\n  return using((arena) {\n    final hProcess = GetCurrentProcess();\n    final pCreationTime = arena<FILETIME>();\n    final pExitTime = arena<FILETIME>();\n    final pKernelTime = arena<FILETIME>();\n    final pUserTime = arena<FILETIME>();\n\n    var Win32Result(:value, :error) = GetProcessTimes(\n      hProcess,\n      pCreationTime,\n      pExitTime,\n      pKernelTime,\n      pUserTime,\n    );\n    if (!value) throw WindowsException(error.toHRESULT());\n\n    final pCreationSystemTime = arena<SYSTEMTIME>();\n    Win32Result(:value, :error) = FileTimeToSystemTime(\n      pCreationTime,\n      pCreationSystemTime,\n    );\n    if (!value) throw WindowsException(error.toHRESULT());\n\n    final SYSTEMTIME(:wYear, :wMonth, :wDay, :wHour, :wMinute, :wSecond) =\n        pCreationSystemTime.ref;\n    return DateTime.utc(wYear, wMonth, wDay, wHour, wMinute, wSecond).toLocal();\n  });\n}\n"})}),"\n",(0,r.jsx)(i,{href:"https://github.com/halildurmus/win32/blob/main/examples/process.dart"}),"\n",(0,r.jsxs)(n.admonition,{type:"danger",children:[(0,r.jsxs)(n.p,{children:["Never store ",(0,r.jsx)(n.code,{children:"Arena"}),"-allocated pointers in fields, globals, or closures that may\noutlive the ",(0,r.jsx)(n.a,{href:"https://pub.dev/documentation/ffi/latest/ffi/using.html",children:(0,r.jsx)(n.code,{children:"using()"})})," scope."]}),(0,r.jsx)(n.p,{children:"Doing so creates dangling pointers that can appear to work and then fail\nunpredictably."})]}),"\n",(0,r.jsxs)(n.h2,{id:"modeling-multiple-lifetimes-with-nested-arenas",children:["Modeling Multiple Lifetimes with Nested ",(0,r.jsx)(n.code,{children:"Arena"}),"s"]}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.code,{children:"Arena"})," defines a ",(0,r.jsx)(n.strong,{children:"single lifetime boundary"}),". In some cases, that boundary\nis too coarse."]}),"\n",(0,r.jsxs)(n.p,{children:["Nested arenas allow you to introduce ",(0,r.jsx)(n.strong,{children:"shorter-lived sub-scopes"})," inside a\nlarger allocation context:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// highlight-next-line\nusing((outerArena) {\n  final globalPtr = outerArena<DWORD>();\n\n  // highlight-next-line\n  using((innerArena) {\n    final temp = innerArena<DWORD>();\n    // temp is valid only within this block\n  }); // temp freed here\n\n  // globalPtr remains valid\n}); // globalPtr freed here\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Each ",(0,r.jsx)(n.code,{children:"using()"})," call creates an ",(0,r.jsx)(n.strong,{children:"independent"})," arena with its own lifetime."]}),"\n",(0,r.jsx)(n.p,{children:"This pattern is useful when temporary allocations would otherwise accumulate\nuntil the end of a long-running scope."}),"\n",(0,r.jsx)(n.h2,{id:"selecting-an-allocation-strategy",children:"Selecting an Allocation Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Use ",(0,r.jsx)(n.code,{children:"Arena"})," when"]}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The lifetime fits within a lexical scope"}),"\n",(0,r.jsx)(n.li,{children:"Allocations are temporary or function-local"}),"\n",(0,r.jsx)(n.li,{children:"You want exception safety by default"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use manual allocation when"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Memory must outlive a function call"}),"\n",(0,r.jsx)(n.li,{children:"State is global or shared"}),"\n",(0,r.jsx)(n.li,{children:"You are making allocations in a tight loop and need to minimize overhead"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Both approaches can be mixed safely:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"late final Pointer<WCHAR> globalBuffer;\n\nvoid setup() {\n  globalBuffer = adaptiveCalloc<WCHAR>(1024);\n}\n\nvoid process() {\n  using((arena) {\n    final temp = arena<DWORD>();\n    copyToBuffer(temp, globalBuffer);\n  });\n}\n\nvoid cleanup() {\n  free(globalBuffer);\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["If you observe unexplained native memory growth, see ",(0,r.jsx)(n.a,{href:"/docs/advanced/leak-tracking",children:"Leak Tracking"})," for runtime\ndetection of leaked allocations."]})})]})}function h(e={}){let{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453(e,n,i){i.d(n,{R:()=>l,x:()=>s});var t=i(96540);let r={},a=t.createContext(r);function l(e){let n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);