"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["6970"],{38807(e,t,n){n.r(t),n.d(t,{metadata:()=>a,default:()=>h,frontMatter:()=>i,contentTitle:()=>c,toc:()=>o,assets:()=>s});var a=JSON.parse('{"id":"advanced/leak-tracking","title":"Leak Tracking","description":"package:ffileaktracker helps you find and","source":"@site/docs/advanced/leak-tracking.md","sourceDirName":"advanced","slug":"/advanced/leak-tracking","permalink":"/docs/advanced/leak-tracking","draft":false,"unlisted":false,"editUrl":"https://github.com/halildurmus/win32/tree/main/website/docs/advanced/leak-tracking.md","tags":[],"version":"current","lastUpdatedBy":"Halil Durmus","lastUpdatedAt":1772220481000,"frontMatter":{"title":"Leak Tracking"},"sidebar":"mainSidebar","previous":{"title":"Methods","permalink":"/docs/advanced/com/methods"},"next":{"title":"Migrating from 5.x.x to 6.x.x","permalink":"/docs/migration/5xx-to-6xx"}}'),r=n(74848),l=n(28453);let i={title:"Leak Tracking"},c,s={},o=[{value:"Allocators",id:"allocators",level:2},{value:"Enabling Tracking",id:"enabling-tracking",level:2},{value:"Globally",id:"globally",level:3},{value:"Scoped Tracking",id:"scoped-tracking",level:3},{value:"Reporting Leaks",id:"reporting-leaks",level:2},{value:"Leak Detection in Tests",id:"leak-detection-in-tests",level:3},{value:"How It Works",id:"how-it-works",level:2},{value:"Example",id:"example",level:2}];function d(e){let t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://pub.dev/packages/ffi_leak_tracker",children:(0,r.jsx)(t.code,{children:"package:ffi_leak_tracker"})})," helps you find and\ndiagnose native memory leaks in Dart FFI code. It tracks allocations made\nthrough its custom allocators and answers one question precisely:"]}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsx)(t.p,{children:"Which native allocations made from Dart were never freed, and where were they\nallocated?"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"When enabled, the tracker records every allocation \u2014 capturing the address,\nsize, type, call stack, and timestamp \u2014 and can report any that were never\nfreed."}),"\n",(0,r.jsx)(t.p,{children:"A few things worth knowing upfront:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Tracking is ",(0,r.jsx)(t.strong,{children:"opt-in"})," and off by default"]}),"\n",(0,r.jsxs)(t.li,{children:["In ",(0,r.jsx)(t.strong,{children:"release"})," builds, adaptive allocators compile away to\n",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi/latest/ffi/calloc-constant.html",children:(0,r.jsx)(t.code,{children:"calloc()"})})," / ",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi/latest/ffi/malloc-constant.html",children:(0,r.jsx)(t.code,{children:"malloc()"})})," with ",(0,r.jsx)(t.strong,{children:"zero-overhead"})]}),"\n",(0,r.jsxs)(t.li,{children:["Only allocations made through ",(0,r.jsx)(t.code,{children:"package:ffi_leak_tracker"})," allocators are\ntracked; \u2014 calls to ",(0,r.jsx)(t.code,{children:"calloc()"})," / ",(0,r.jsx)(t.code,{children:"malloc()"})," directly are not visible to the\ntracker."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"allocators",children:"Allocators"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"package:ffi_leak_tracker"})," provides four allocators:"]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Allocator"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Zeroes memory"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Release build"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/adaptiveCalloc-constant.html",children:(0,r.jsx)(t.code,{children:"adaptiveCalloc"})})}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsxs)(t.td,{style:{textAlign:"center"},children:["compile away to ",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi/latest/ffi/calloc-constant.html",children:(0,r.jsx)(t.code,{children:"calloc"})})]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/adaptiveMalloc-constant.html",children:(0,r.jsx)(t.code,{children:"adaptiveMalloc"})})}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"\u2717"}),(0,r.jsxs)(t.td,{style:{textAlign:"center"},children:["compile away to ",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi/latest/ffi/malloc-constant.html",children:(0,r.jsx)(t.code,{children:"malloc"})})]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/diagnosticCalloc-constant.html",children:(0,r.jsx)(t.code,{children:"diagnosticCalloc"})})}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"\u2713"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"retains tracking"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/diagnosticMalloc-constant.html",children:(0,r.jsx)(t.code,{children:"diagnosticMalloc"})})}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"\u2717"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:"retains tracking"})]})]})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Adaptive allocators"})," are the right default for most code They participate in\nleak tracking in ",(0,r.jsx)(t.strong,{children:"debug"})," and ",(0,r.jsx)(t.strong,{children:"profile"})," builds and disappear entirely in\n",(0,r.jsx)(t.strong,{children:"release"})," builds, so there is no overhead."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Diagnostic allocators"})," retain tracking in all build modes. Use them only when\nyou need to investigate leaks that reproduce exclusively in ",(0,r.jsx)(t.strong,{children:"release"})," builds\n\u2014 they carry measurable overhead and are not suitable as general-purpose\nallocators."]}),"\n",(0,r.jsx)(t.h2,{id:"enabling-tracking",children:"Enabling Tracking"}),"\n",(0,r.jsxs)(t.p,{children:["Importing ",(0,r.jsx)(t.code,{children:"package:ffi_leak_tracker"})," and using its allocators does not\nautomatically start tracking. This lets you control exactly when tracking is\nactive and avoid recording allocations you don't care about."]}),"\n",(0,r.jsx)(t.h3,{id:"globally",children:"Globally"}),"\n",(0,r.jsxs)(t.p,{children:["Call ",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/LeakTracker/enable.html",children:(0,r.jsx)(t.code,{children:"LeakTracker.enable()"})})," early in your program to enable tracking\nfor the entire process lifetime:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"void main() {\n  // highlight-next-line\n  LeakTracker.enable();\n  // ... rest of your code\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["For most applications, you only want tracking in ",(0,r.jsx)(t.strong,{children:"debug"})," and ",(0,r.jsx)(t.strong,{children:"profile"}),"\nbuilds. Use ",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/LeakTracker/enableInDebug.html",children:(0,r.jsx)(t.code,{children:"LeakTracker.enableInDebug()"})})," instead \u2014 it is\ntree-shaken away in ",(0,r.jsx)(t.strong,{children:"release"})," builds and is equivalent to wrapping\n",(0,r.jsx)(t.code,{children:"LeakTracker.enable()"})," in a ",(0,r.jsx)(t.code,{children:"!kReleaseMode"})," guard:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"void main() {\n  // highlight-next-line\n  LeakTracker.enableInDebug();\n  // ... rest of your code\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["To stop recording, call ",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/disableLeakTracking.html",children:(0,r.jsx)(t.code,{children:"LeakTracker.disable()"})}),". To query the current\nstate, read ",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/LeakTracker/enabled.html",children:(0,r.jsx)(t.code,{children:"LeakTracker.enabled"})}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"scoped-tracking",children:"Scoped Tracking"}),"\n",(0,r.jsxs)(t.p,{children:["To isolate tracking to a specific operation \u2014 such as a single test or\nbenchmark \u2014 use ",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/LeakTracker/runScoped.html",children:(0,r.jsx)(t.code,{children:"LeakTracker.runScoped()"})}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"LeakTracker.runScoped(() {\n  // Only allocations made inside this callback are tracked.\n  final ptr = adaptiveCalloc<Int32>();\n  adaptiveCalloc.free(ptr);\n});\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Tracking is automatically enabled for the duration of the callback. The scope\nmaintains its own isolated registry, independent of any outer tracking context.\nAn optional ",(0,r.jsx)(t.code,{children:"filter"})," parameter lets you suppress specific allocations within\nthe scope."]}),"\n",(0,r.jsx)(t.h2,{id:"reporting-leaks",children:"Reporting Leaks"}),"\n",(0,r.jsxs)(t.p,{children:["Call ",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/LeakTracker/emit.html",children:(0,r.jsx)(t.code,{children:"LeakTracker.emit()"})})," at any point to print outstanding (un-freed)\nallocations:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"void main() {\n  LeakTracker.enableInDebug();\n  // ... rest of your code\n  // highlight-next-line\n  LeakTracker.emit();\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["By default, output goes to the console. Pass a custom\n",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/LeaksEmitter.html",children:(0,r.jsx)(t.code,{children:"LeaksEmitter"})})," to redirect it \u2014 for example, to a JSON file,\na logging framework, or a test reporter:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"LeakTracker.emit(emitter: const .json('leaks.json'));\n\n// Or with a fully custom emitter:\nLeakTracker.emit(emitter: const MyCustomEmitter());\n"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"LeakTracker.emit()"})," does not clear the registry. To reset it, call\n",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/LeakTracker/reset.html",children:(0,r.jsx)(t.code,{children:"LeakTracker.reset()"})}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["To assert that no leaks are present \u2014 and throw a ",(0,r.jsx)(t.code,{children:"LeakTrackerException"})," if\nany tracked allocations remain \u2014 use\n",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/LeakTracker/verifyNoLeaks.html",children:(0,r.jsx)(t.code,{children:"LeakTracker.verifyNoLeaks()"})}),". The debug-only variant,\n",(0,r.jsx)(t.a,{href:"https://pub.dev/documentation/ffi_leak_tracker/latest/ffi_leak_tracker/LeakTracker/verifyNoLeaksInDebug.html",children:(0,r.jsx)(t.code,{children:"LeakTracker.verifyNoLeaksInDebug()"})}),", is a no-op in\nrelease builds:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"void main() {\n  LeakTracker.enableInDebug();\n  // ... rest of your code\n  // highlight-next-line\n  LeakTracker.verifyNoLeaksInDebug();\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"leak-detection-in-tests",children:"Leak Detection in Tests"}),"\n",(0,r.jsx)(t.p,{children:"The snippet below enables tracking for an entire test suite, resets the\nregistry before each test, and asserts no leaks remain after each test \u2014 with\nno boilerplate required in the tests themselves:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"import 'dart:ffi';\n\nimport 'package:ffi_leak_tracker/ffi_leak_tracker.dart';\nimport 'package:test/test.dart';\n\nvoid main() {\n  // highlight-next-line\n  setUpAll(LeakTracker.enableInDebug);\n\n  // highlight-next-line\n  setUp(LeakTracker.reset);\n\n  // highlight-next-line\n  tearDown(LeakTracker.verifyNoLeaksInDebug);\n\n  test('my native memory test', () {\n    final ptr = adaptiveCalloc<Int32>();\n    // ... test code\n    adaptiveCalloc.free(ptr);\n  });\n\n  // ... more tests\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["An allocation is made through a ",(0,r.jsx)(t.code,{children:"package:ffi_leak_tracker"})," allocator while\ntracking is enabled."]}),"\n",(0,r.jsx)(t.li,{children:"The allocator registers the allocation with the tracker, recording its\naddress, size, type, timestamp, and current call stack."}),"\n",(0,r.jsxs)(t.li,{children:["When the memory is freed via the same allocator's ",(0,r.jsx)(t.code,{children:"free()"}),", the tracker\nremoves the record from its registry."]}),"\n",(0,r.jsxs)(t.li,{children:["When ",(0,r.jsx)(t.code,{children:"LeakTracker.emit()"})," or ",(0,r.jsx)(t.code,{children:"LeakTracker.verifyNoLeaks()"})," is called, any\nallocation still present in the registry is reported as a leak."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"import 'dart:ffi';\n\nimport 'package:ffi_leak_tracker/ffi_leak_tracker.dart';\n\nvoid main() {\n  // Enable tracking only in debug/profile builds.\n  LeakTracker.enableInDebug();\n\n  print('Allocating memory without freeing it...');\n  final ptr = adaptiveCalloc<Int32>();\n\n  // Fix the leak by uncommenting:\n  // adaptiveCalloc.free(ptr);\n\n  print('Verifying for leaks...');\n\n  // In debug builds this throws if any allocations remain.\n  LeakTracker.verifyNoLeaksInDebug();\n\n  print('No leaks detected.');\n}\n"})})]})}function h(e={}){let{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453(e,t,n){n.d(t,{R:()=>i,x:()=>c});var a=n(96540);let r={},l=a.createContext(r);function i(e){let t=a.useContext(l);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(l.Provider,{value:t},e.children)}}}]);