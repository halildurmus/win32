ole32.dll|
import 'dart:ffi';

import 'package:ffi/ffi.dart';
import 'package:ffi_leak_tracker/ffi_leak_tracker.dart';

import '../bstr.dart';
import '../com/imalloc.g.dart';
import '../com/interface.g.dart';
import '../com/istream.g.dart';
import '../com/iunknown.g.dart';
import '../constants.dart';
import '../constants.g.dart';
import '../enums.g.dart';
import '../exception.dart';
import '../extensions/pointer.dart';
import '../guid.dart';
import '../hresult.dart';
import '../hstring.dart';
import '../macros.dart';
import '../ntstatus.dart';
import '../pcstr.dart';
import '../pcwstr.dart';
import '../propvariant.dart';
import '../pstr.dart';
import '../pwstr.dart';
import '../rpc_status.dart';
import '../structs.g.dart';
import '../types.dart';
import '../utils.dart';
import '../win32_error.dart';
import '../win32_result.dart';

/// Looks up a CLSID in the registry, given a ProgID.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-clsidfromprogid>.
///
/// {@category ole32}
Pointer<GUID> CLSIDFromProgID(PCWSTR lpszProgID) {
  final lpclsid = adaptiveCalloc<GUID>();
  final hr$ = HRESULT(_CLSIDFromProgID(lpszProgID, lpclsid));
  if (hr$.isError) {
    free(lpclsid);
    throw WindowsException(hr$);
  }
  return lpclsid;
}

@Native<Int32 Function(Pointer<Utf16>, Pointer<GUID>)>(
  symbol: 'CLSIDFromProgID',
)
external int _CLSIDFromProgID(Pointer<Utf16> lpszProgID, Pointer<GUID> lpclsid);

/// Triggers automatic installation if the COMClassStore policy is enabled.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-clsidfromprogidex>.
///
/// {@category ole32}
Pointer<GUID> CLSIDFromProgIDEx(PCWSTR lpszProgID) {
  final lpclsid = adaptiveCalloc<GUID>();
  final hr$ = HRESULT(_CLSIDFromProgIDEx(lpszProgID, lpclsid));
  if (hr$.isError) {
    free(lpclsid);
    throw WindowsException(hr$);
  }
  return lpclsid;
}

@Native<Int32 Function(Pointer<Utf16>, Pointer<GUID>)>(
  symbol: 'CLSIDFromProgIDEx',
)
external int _CLSIDFromProgIDEx(
  Pointer<Utf16> lpszProgID,
  Pointer<GUID> lpclsid,
);

/// Converts a string generated by the StringFromCLSID function back into the
/// original CLSID.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-clsidfromstring>.
///
/// {@category ole32}
Pointer<GUID> CLSIDFromString(PCWSTR lpsz) {
  final pclsid = adaptiveCalloc<GUID>();
  final hr$ = HRESULT(_CLSIDFromString(lpsz, pclsid));
  if (hr$.isError) {
    free(pclsid);
    throw WindowsException(hr$);
  }
  return pclsid;
}

@Native<Int32 Function(Pointer<Utf16>, Pointer<GUID>)>(
  symbol: 'CLSIDFromString',
)
external int _CLSIDFromString(Pointer<Utf16> lpsz, Pointer<GUID> pclsid);

/// Increments a global per-process reference count.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-coaddrefserverprocess>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
int CoAddRefServerProcess() => _CoAddRefServerProcess();

@Native<Uint32 Function()>(symbol: 'CoAddRefServerProcess')
external int _CoAddRefServerProcess();

/// Creates a GUID, a unique 128-bit integer used for CLSIDs and interface
/// identifiers.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cocreateguid>.
///
/// {@category ole32}
Pointer<GUID> CoCreateGuid() {
  final pguid = adaptiveCalloc<GUID>();
  final hr$ = HRESULT(_CoCreateGuid(pguid));
  if (hr$.isError) {
    free(pguid);
    throw WindowsException(hr$);
  }
  return pguid;
}

@Native<Int32 Function(Pointer<GUID>)>(symbol: 'CoCreateGuid')
external int _CoCreateGuid(Pointer<GUID> pguid);

/// Creates a single uninitialized object of the class associated with a
/// specified CLSID.
///
/// This method uses the [ComInterface.type] method to retrieve metadata about
/// the target interface defined by [T], including its IID (Interface ID) and
/// instantiation logic.
///
/// All COM interfaces provided by this package are pre-registered. Custom COM
/// interfaces must be registered manually using the [ComInterface.register]
/// method before calling this method.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance>.
///
/// {@category ole32}
T CoCreateInstance<T extends IUnknown>(
  Pointer<GUID> rclsid,
  IUnknown? pUnkOuter,
  CLSCTX dwClsContext,
) {
  final companion = ComInterface.type<T>();
  final riid = companion.iid.toNative();
  final ppv = adaptiveCalloc<Pointer>();
  final hr$ = HRESULT(
    _CoCreateInstance(
      rclsid,
      pUnkOuter?.ptr ?? nullptr,
      dwClsContext,
      riid,
      ppv,
    ),
  );
  free(riid);
  if (hr$.isError) {
    free(ppv);
    throw WindowsException(hr$);
  }
  final result = companion.fromPointer(ppv.value.cast());
  free(ppv);
  return result;
}

@Native<
  Int32 Function(
    Pointer<GUID>,
    VTablePointer,
    Uint32,
    Pointer<GUID>,
    Pointer<Pointer>,
  )
>(symbol: 'CoCreateInstance')
external int _CoCreateInstance(
  Pointer<GUID> rclsid,
  VTablePointer pUnkOuter,
  int dwClsContext,
  Pointer<GUID> riid,
  Pointer<Pointer> ppv,
);

/// Releases the increment made by a previous call to the CoIncrementMTAUsage
/// function.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-codecrementmtausage>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
void CoDecrementMTAUsage(CO_MTA_USAGE_COOKIE cookie) {
  final hr$ = HRESULT(_CoDecrementMTAUsage(cookie));
  if (hr$.isError) throw WindowsException(hr$);
}

@Native<Int32 Function(Pointer)>(symbol: 'CoDecrementMTAUsage')
external int _CoDecrementMTAUsage(Pointer cookie);

/// Returns the current apartment type and type qualifier.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cogetapartmenttype>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
void CoGetApartmentType(Pointer<Int32> pAptType, Pointer<Int32> pAptQualifier) {
  final hr$ = HRESULT(_CoGetApartmentType(pAptType, pAptQualifier));
  if (hr$.isError) throw WindowsException(hr$);
}

@Native<Int32 Function(Pointer<Int32>, Pointer<Int32>)>(
  symbol: 'CoGetApartmentType',
)
external int _CoGetApartmentType(
  Pointer<Int32> pAptType,
  Pointer<Int32> pAptQualifier,
);

/// Provides a pointer to an interface on a class object associated with a
/// specified CLSID.
///
/// This method uses the [ComInterface.type] method to retrieve metadata about
/// the target interface defined by [T], including its IID (Interface ID) and
/// instantiation logic.
///
/// All COM interfaces provided by this package are pre-registered. Custom COM
/// interfaces must be registered manually using the [ComInterface.register]
/// method before calling this method.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cogetclassobject>.
///
/// {@category ole32}
T CoGetClassObject<T extends IUnknown>(
  Pointer<GUID> rclsid,
  CLSCTX dwClsContext,
) {
  final companion = ComInterface.type<T>();
  final riid = companion.iid.toNative();
  final ppv = adaptiveCalloc<Pointer>();
  final hr$ = HRESULT(
    _CoGetClassObject(rclsid, dwClsContext, nullptr, riid, ppv),
  );
  free(riid);
  if (hr$.isError) {
    free(ppv);
    throw WindowsException(hr$);
  }
  final result = companion.fromPointer(ppv.value.cast());
  free(ppv);
  return result;
}

@Native<
  Int32 Function(
    Pointer<GUID>,
    Uint32,
    Pointer,
    Pointer<GUID>,
    Pointer<Pointer>,
  )
>(symbol: 'CoGetClassObject')
external int _CoGetClassObject(
  Pointer<GUID> rclsid,
  int dwClsContext,
  Pointer pvReserved,
  Pointer<GUID> riid,
  Pointer<Pointer> ppv,
);

/// Returns a value that is unique to the current thread.
///
/// CoGetCurrentProcess can be used to avoid thread ID reuse problems.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cogetcurrentprocess>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
int CoGetCurrentProcess() => _CoGetCurrentProcess();

@Native<Uint32 Function()>(symbol: 'CoGetCurrentProcess')
external int _CoGetCurrentProcess();

/// Retrieves a pointer to the default OLE task memory allocator (which supports
/// the system implementation of the IMalloc interface) so applications can call
/// its methods to manage memory.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cogetmalloc>.
///
/// {@category ole32}
IMalloc? CoGetMalloc(int dwMemContext) {
  final ppMalloc = adaptiveCalloc<VTablePointer>();
  final hr$ = HRESULT(_CoGetMalloc(dwMemContext, ppMalloc));
  if (hr$.isError) {
    free(ppMalloc);
    throw WindowsException(hr$);
  }
  final result$ = ppMalloc.value;
  free(ppMalloc);
  if (result$.isNull) return null;
  return IMalloc(result$);
}

@Native<Int32 Function(Uint32, Pointer<VTablePointer>)>(symbol: 'CoGetMalloc')
external int _CoGetMalloc(int dwMemContext, Pointer<VTablePointer> ppMalloc);

/// Keeps MTA support active when no MTA threads are running.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-coincrementmtausage>.
///
/// {@category ole32}
CO_MTA_USAGE_COOKIE CoIncrementMTAUsage() {
  final pCookie = adaptiveCalloc<Pointer>();
  final hr$ = HRESULT(_CoIncrementMTAUsage(pCookie));
  if (hr$.isError) {
    free(pCookie);
    throw WindowsException(hr$);
  }
  final result$ = pCookie.value;
  free(pCookie);
  return CO_MTA_USAGE_COOKIE(result$);
}

@Native<Int32 Function(Pointer<Pointer>)>(symbol: 'CoIncrementMTAUsage')
external int _CoIncrementMTAUsage(Pointer<Pointer> pCookie);

/// Initializes the COM library for use by the calling thread, sets the thread's
/// concurrency model, and creates a new apartment for the thread if one is
/// required.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
HRESULT CoInitializeEx(COINIT dwCoInit) =>
    HRESULT(_CoInitializeEx(nullptr, dwCoInit));

@Native<Int32 Function(Pointer, Uint32)>(symbol: 'CoInitializeEx')
external int _CoInitializeEx(Pointer pvReserved, int dwCoInit);

/// Registers security and sets the default security values for the process.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-coinitializesecurity>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
void CoInitializeSecurity(
  PSECURITY_DESCRIPTOR? pSecDesc,
  int cAuthSvc,
  Pointer<SOLE_AUTHENTICATION_SERVICE>? asAuthSvc,
  RPC_C_AUTHN_LEVEL dwAuthnLevel,
  RPC_C_IMP_LEVEL dwImpLevel,
  Pointer? pAuthList,
  EOLE_AUTHENTICATION_CAPABILITIES dwCapabilities,
) {
  final hr$ = HRESULT(
    _CoInitializeSecurity(
      pSecDesc ?? nullptr,
      cAuthSvc,
      asAuthSvc ?? nullptr,
      nullptr,
      dwAuthnLevel,
      dwImpLevel,
      pAuthList ?? nullptr,
      dwCapabilities,
      nullptr,
    ),
  );
  if (hr$.isError) throw WindowsException(hr$);
}

@Native<
  Int32 Function(
    Pointer,
    Int32,
    Pointer<SOLE_AUTHENTICATION_SERVICE>,
    Pointer,
    Uint32,
    Uint32,
    Pointer,
    Uint32,
    Pointer,
  )
>(symbol: 'CoInitializeSecurity')
external int _CoInitializeSecurity(
  Pointer pSecDesc,
  int cAuthSvc,
  Pointer<SOLE_AUTHENTICATION_SERVICE> asAuthSvc,
  Pointer pReserved1,
  int dwAuthnLevel,
  int dwImpLevel,
  Pointer pAuthList,
  int dwCapabilities,
  Pointer pReserved3,
);

/// Sets the authentication information that will be used to make calls on the
/// specified proxy.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cosetproxyblanket>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
void CoSetProxyBlanket(
  IUnknown? pProxy,
  int dwAuthnSvc,
  int dwAuthzSvc,
  PCWSTR? pServerPrincName,
  RPC_C_AUTHN_LEVEL dwAuthnLevel,
  RPC_C_IMP_LEVEL dwImpLevel,
  Pointer? pAuthInfo,
  EOLE_AUTHENTICATION_CAPABILITIES dwCapabilities,
) {
  final hr$ = HRESULT(
    _CoSetProxyBlanket(
      pProxy?.ptr ?? nullptr,
      dwAuthnSvc,
      dwAuthzSvc,
      pServerPrincName ?? nullptr,
      dwAuthnLevel,
      dwImpLevel,
      pAuthInfo ?? nullptr,
      dwCapabilities,
    ),
  );
  if (hr$.isError) throw WindowsException(hr$);
}

@Native<
  Int32 Function(
    VTablePointer,
    Uint32,
    Uint32,
    Pointer<Utf16>,
    Uint32,
    Uint32,
    Pointer,
    Uint32,
  )
>(symbol: 'CoSetProxyBlanket')
external int _CoSetProxyBlanket(
  VTablePointer pProxy,
  int dwAuthnSvc,
  int dwAuthzSvc,
  Pointer<Utf16> pServerPrincName,
  int dwAuthnLevel,
  int dwImpLevel,
  Pointer pAuthInfo,
  int dwCapabilities,
);

/// Allocates a block of task memory in the same way that `IMalloc.alloc` does.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemalloc>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
Pointer CoTaskMemAlloc(int cb) => _CoTaskMemAlloc(cb);

@Native<Pointer Function(IntPtr)>(symbol: 'CoTaskMemAlloc')
external Pointer _CoTaskMemAlloc(int cb);

/// Frees a block of task memory previously allocated through a call to the
/// CoTaskMemAlloc or CoTaskMemRealloc function.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemfree>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
void CoTaskMemFree(Pointer? pv) => _CoTaskMemFree(pv ?? nullptr);

@Native<Void Function(Pointer)>(symbol: 'CoTaskMemFree')
external void _CoTaskMemFree(Pointer pv);

/// Changes the size of a previously allocated block of task memory.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemrealloc>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
Pointer CoTaskMemRealloc(Pointer? pv, int cb) =>
    _CoTaskMemRealloc(pv ?? nullptr, cb);

@Native<Pointer Function(Pointer, IntPtr)>(symbol: 'CoTaskMemRealloc')
external Pointer _CoTaskMemRealloc(Pointer pv, int cb);

/// Closes the COM library on the current thread, unloads all DLLs loaded by the
/// thread, frees any other resources that the thread maintains, and forces all
/// RPC connections on the thread to close.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-couninitialize>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
void CoUninitialize() => _CoUninitialize();

@Native<Void Function()>(symbol: 'CoUninitialize')
external void _CoUninitialize();

/// Waits for specified handles to be signaled or for a specified timeout period
/// to elapse.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cowaitformultiplehandles>.
///
/// {@category ole32}
int CoWaitForMultipleHandles(
  int dwFlags,
  int dwTimeout,
  int cHandles,
  Pointer<Pointer> pHandles,
) {
  final lpdwindex = adaptiveCalloc<Uint32>();
  final hr$ = HRESULT(
    _CoWaitForMultipleHandles(
      dwFlags,
      dwTimeout,
      cHandles,
      pHandles,
      lpdwindex,
    ),
  );
  if (hr$.isError) {
    free(lpdwindex);
    throw WindowsException(hr$);
  }
  final result$ = lpdwindex.value;
  free(lpdwindex);
  return result$;
}

@Native<
  Int32 Function(Uint32, Uint32, Uint32, Pointer<Pointer>, Pointer<Uint32>)
>(symbol: 'CoWaitForMultipleHandles')
external int _CoWaitForMultipleHandles(
  int dwFlags,
  int dwTimeout,
  int cHandles,
  Pointer<Pointer> pHandles,
  Pointer<Uint32> lpdwindex,
);

/// A replacement for CoWaitForMultipleHandles.
///
/// This replacement API hides the options for CoWaitForMultipleHandles that are
/// not supported in ASTA.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cowaitformultipleobjects>.
///
/// {@category ole32}
int CoWaitForMultipleObjects(
  int dwFlags,
  int dwTimeout,
  int cHandles,
  Pointer<Pointer> pHandles,
) {
  final lpdwindex = adaptiveCalloc<Uint32>();
  final hr$ = HRESULT(
    _CoWaitForMultipleObjects(
      dwFlags,
      dwTimeout,
      cHandles,
      pHandles,
      lpdwindex,
    ),
  );
  if (hr$.isError) {
    free(lpdwindex);
    throw WindowsException(hr$);
  }
  final result$ = lpdwindex.value;
  free(lpdwindex);
  return result$;
}

@Native<
  Int32 Function(Uint32, Uint32, Uint32, Pointer<Pointer>, Pointer<Uint32>)
>(symbol: 'CoWaitForMultipleObjects')
external int _CoWaitForMultipleObjects(
  int dwFlags,
  int dwTimeout,
  int cHandles,
  Pointer<Pointer> pHandles,
  Pointer<Uint32> lpdwindex,
);

/// Creates a stream object that uses an HGLOBAL memory handle to store the
/// stream contents.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-createstreamonhglobal>.
///
/// {@category ole32}
IStream? CreateStreamOnHGlobal(HGLOBAL? hGlobal, bool fDeleteOnRelease) {
  final ppstm = adaptiveCalloc<VTablePointer>();
  final hr$ = HRESULT(
    _CreateStreamOnHGlobal(
      hGlobal ?? nullptr,
      fDeleteOnRelease ? TRUE : FALSE,
      ppstm,
    ),
  );
  if (hr$.isError) {
    free(ppstm);
    throw WindowsException(hr$);
  }
  final result$ = ppstm.value;
  free(ppstm);
  if (result$.isNull) return null;
  return IStream(result$);
}

@Native<Int32 Function(Pointer, Int32, Pointer<VTablePointer>)>(
  symbol: 'CreateStreamOnHGlobal',
)
external int _CreateStreamOnHGlobal(
  Pointer hGlobal,
  int fDeleteOnRelease,
  Pointer<VTablePointer> ppstm,
);

/// Returns the CLSID associated with the specified file name.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/objbase/nf-objbase-getclassfile>.
///
/// {@category ole32}
Pointer<GUID> GetClassFile(PCWSTR szFilename) {
  final pclsid = adaptiveCalloc<GUID>();
  final hr$ = HRESULT(_GetClassFile(szFilename, pclsid));
  if (hr$.isError) {
    free(pclsid);
    throw WindowsException(hr$);
  }
  return pclsid;
}

@Native<Int32 Function(Pointer<Utf16>, Pointer<GUID>)>(symbol: 'GetClassFile')
external int _GetClassFile(Pointer<Utf16> szFilename, Pointer<GUID> pclsid);

/// Retrieves the global memory handle to a stream that was created through a
/// call to the CreateStreamOnHGlobal function.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-gethglobalfromstream>.
///
/// {@category ole32}
HGLOBAL GetHGlobalFromStream(IStream? pstm) {
  final phglobal = adaptiveCalloc<Pointer>();
  final hr$ = HRESULT(_GetHGlobalFromStream(pstm?.ptr ?? nullptr, phglobal));
  if (hr$.isError) {
    free(phglobal);
    throw WindowsException(hr$);
  }
  final result$ = phglobal.value;
  free(phglobal);
  return HGLOBAL(result$);
}

@Native<Int32 Function(VTablePointer, Pointer<Pointer>)>(
  symbol: 'GetHGlobalFromStream',
)
external int _GetHGlobalFromStream(
  VTablePointer pstm,
  Pointer<Pointer> phglobal,
);

/// Converts a string generated by the StringFromIID function back into the
/// original interface identifier (IID).
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-iidfromstring>.
///
/// {@category ole32}
Pointer<GUID> IIDFromString(PCWSTR lpsz) {
  final lpiid = adaptiveCalloc<GUID>();
  final hr$ = HRESULT(_IIDFromString(lpsz, lpiid));
  if (hr$.isError) {
    free(lpiid);
    throw WindowsException(hr$);
  }
  return lpiid;
}

@Native<Int32 Function(Pointer<Utf16>, Pointer<GUID>)>(symbol: 'IIDFromString')
external int _IIDFromString(Pointer<Utf16> lpsz, Pointer<GUID> lpiid);

/// Initializes the COM library on the current apartment and identifies the
/// concurrency model as single-thread apartment (STA).
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/ole2/nf-ole2-oleinitialize>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
void OleInitialize() {
  final hr$ = HRESULT(_OleInitialize(nullptr));
  if (hr$.isError) throw WindowsException(hr$);
}

@Native<Int32 Function(Pointer)>(symbol: 'OleInitialize')
external int _OleInitialize(Pointer pvReserved);

/// Closes the COM library on the apartment, releases any class factories, other
/// COM objects, or servers held by the apartment, disables RPC on the
/// apartment, and frees any resources the apartment maintains.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/ole2/nf-ole2-oleuninitialize>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
void OleUninitialize() => _OleUninitialize();

@Native<Void Function()>(symbol: 'OleUninitialize')
external void _OleUninitialize();

/// Retrieves the ProgID for a given CLSID.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-progidfromclsid>.
///
/// {@category ole32}
PWSTR ProgIDFromCLSID(Pointer<GUID> clsid) {
  final lplpszProgID = adaptiveCalloc<Pointer<Utf16>>();
  final hr$ = HRESULT(_ProgIDFromCLSID(clsid, lplpszProgID));
  if (hr$.isError) {
    free(lplpszProgID);
    throw WindowsException(hr$);
  }
  final result$ = lplpszProgID.value;
  free(lplpszProgID);
  return PWSTR(result$);
}

@Native<Int32 Function(Pointer<GUID>, Pointer<Pointer<Utf16>>)>(
  symbol: 'ProgIDFromCLSID',
)
external int _ProgIDFromCLSID(
  Pointer<GUID> clsid,
  Pointer<Pointer<Utf16>> lplpszProgID,
);

/// Frees all elements that can be freed in a given PROPVARIANT structure.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
void PropVariantClear(Pointer<PROPVARIANT> pvar) {
  final hr$ = HRESULT(_PropVariantClear(pvar));
  if (hr$.isError) throw WindowsException(hr$);
}

@Native<Int32 Function(Pointer<PROPVARIANT>)>(symbol: 'PropVariantClear')
external int _PropVariantClear(Pointer<PROPVARIANT> pvar);

/// Copies the contents of one PROPVARIANT structure to another.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-propvariantcopy>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
void PropVariantCopy(
  Pointer<PROPVARIANT> pvarDest,
  Pointer<PROPVARIANT> pvarSrc,
) {
  final hr$ = HRESULT(_PropVariantCopy(pvarDest, pvarSrc));
  if (hr$.isError) throw WindowsException(hr$);
}

@Native<Int32 Function(Pointer<PROPVARIANT>, Pointer<PROPVARIANT>)>(
  symbol: 'PropVariantCopy',
)
external int _PropVariantCopy(
  Pointer<PROPVARIANT> pvarDest,
  Pointer<PROPVARIANT> pvarSrc,
);

/// Converts a CLSID into a string of printable characters.
///
/// Different CLSIDs always convert to different strings.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-stringfromclsid>.
///
/// {@category ole32}
PWSTR StringFromCLSID(Pointer<GUID> rclsid) {
  final lplpsz = adaptiveCalloc<Pointer<Utf16>>();
  final hr$ = HRESULT(_StringFromCLSID(rclsid, lplpsz));
  if (hr$.isError) {
    free(lplpsz);
    throw WindowsException(hr$);
  }
  final result$ = lplpsz.value;
  free(lplpsz);
  return PWSTR(result$);
}

@Native<Int32 Function(Pointer<GUID>, Pointer<Pointer<Utf16>>)>(
  symbol: 'StringFromCLSID',
)
external int _StringFromCLSID(
  Pointer<GUID> rclsid,
  Pointer<Pointer<Utf16>> lplpsz,
);

/// Converts a globally unique identifier (GUID) into a string of printable
/// characters.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-stringfromguid2>.
///
/// {@category ole32}
@pragma('vm:prefer-inline')
int StringFromGUID2(Pointer<GUID> rguid, PWSTR lpsz, int cchMax) =>
    _StringFromGUID2(rguid, lpsz, cchMax);

@Native<Int32 Function(Pointer<GUID>, Pointer<Utf16>, Int32)>(
  symbol: 'StringFromGUID2',
)
external int _StringFromGUID2(
  Pointer<GUID> rguid,
  Pointer<Utf16> lpsz,
  int cchMax,
);

/// Converts an interface identifier into a string of printable characters.
///
/// Throws a [WindowsException] on failure.
///
/// To learn more, see
/// <https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-stringfromiid>.
///
/// {@category ole32}
PWSTR StringFromIID(Pointer<GUID> rclsid) {
  final lplpsz = adaptiveCalloc<Pointer<Utf16>>();
  final hr$ = HRESULT(_StringFromIID(rclsid, lplpsz));
  if (hr$.isError) {
    free(lplpsz);
    throw WindowsException(hr$);
  }
  final result$ = lplpsz.value;
  free(lplpsz);
  return PWSTR(result$);
}

@Native<Int32 Function(Pointer<GUID>, Pointer<Pointer<Utf16>>)>(
  symbol: 'StringFromIID',
)
external int _StringFromIID(
  Pointer<GUID> rclsid,
  Pointer<Pointer<Utf16>> lplpsz,
);
